<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/revista_lor_logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preconnect" href="https://images.pexels.com" crossorigin />
    <link rel="preconnect" href="https://jdluawvgexbygybbghmw.supabase.co" crossorigin />
    <link rel="dns-prefetch" href="https://images.pexels.com" />
    <link rel="dns-prefetch" href="https://jdluawvgexbygybbghmw.supabase.co" />

    <link rel="preload" href="/revista_lor_logo.png" as="image" />

    <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" media="print" onload="this.media='all'" />
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" /></noscript>
    <script type="module">
      const CACHE_KEY = 'revista_hero_articles';
      const CACHE_DURATION = 5 * 60 * 1000;
      const HERO_LIMIT = 9;

      const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
      const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
      const heroEndpoint =
        supabaseUrl &&
        `${supabaseUrl}/rest/v1/articles?select=id,title,slug,category,author,image_url,published_at&order=published_at.desc&limit=${HERO_LIMIT}`;

      const hasFreshCache = () => {
        try {
          const cached = localStorage.getItem(CACHE_KEY);
          if (!cached) return false;

          const { timestamp } = JSON.parse(cached);
          return Date.now() - timestamp < CACHE_DURATION;
        } catch (error) {
          console.warn('Hero cache not available', error);
          return false;
        }
      };

      const formatDate = (value) =>
        new Date(value).toLocaleDateString('ro-RO', {
          day: 'numeric',
          month: 'long',
          year: 'numeric'
        });

      const getPlaceholderDataUrl = (url) => {
        if (!url) return undefined;
        const baseUrl = url.split('?')[0];
        if (url.includes('pexels.com')) {
          return `${baseUrl}?auto=compress&cs=tinysrgb&w=32&q=12&blur=40&fm=webp`;
        }
        if (url.includes('unsplash.com')) {
          return `${baseUrl}?w=32&q=12&auto=format&blur=40`;
        }
        return undefined;
      };

      const cacheArticles = (data) => {
        try {
          const articles = data.map((article) => ({
            id: article.id,
            title: article.title,
            category: article.category,
            author: article.author,
            date: formatDate(article.published_at),
            imageUrl: article.image_url,
            slug: article.slug,
            placeholderDataUrl: getPlaceholderDataUrl(article.image_url)
          }));

          localStorage.setItem(
            CACHE_KEY,
            JSON.stringify({
              articles,
              timestamp: Date.now()
            })
          );
        } catch (error) {
          console.warn('Hero cache skipped', error);
        }
      };

      async function preloadHero() {
        if (!heroEndpoint || !supabaseAnonKey || hasFreshCache()) return;

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2500);

        try {
          const response = await fetch(heroEndpoint, {
            headers: {
              apikey: supabaseAnonKey,
              Authorization: `Bearer ${supabaseAnonKey}`
            },
            signal: controller.signal,
            cache: 'no-store'
          });

          if (!response.ok) return;

          const data = await response.json();
          if (Array.isArray(data) && data.length) {
            cacheArticles(data);
          }
        } catch (error) {
          console.warn('Hero preload failed', error);
        } finally {
          clearTimeout(timeoutId);
        }
      }

      const schedulePreload = () => {
        if (typeof requestIdleCallback === 'function') {
          requestIdleCallback(() => preloadHero(), { timeout: 500 });
        } else {
          setTimeout(preloadHero, 0);
        }
      };

      if (document.readyState === 'complete') {
        schedulePreload();
      } else {
        window.addEventListener('load', schedulePreload, { once: true });
      }
    </script>
    <title>Revista LOR</title>
    <meta property="og:image" content="https://bolt.new/static/og_default.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://bolt.new/static/og_default.png">
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
